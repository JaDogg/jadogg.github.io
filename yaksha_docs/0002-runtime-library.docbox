# Yaksha library
---
Yaksha library uses multiple 3rd party libraries, set of python scripts and few other nuts and bolts to create library sources. 
---
All exposed functionality starts with `yk__` or `YK__`. Yaksha programming language preserves anything that starts with `yk__` or `YK__` while prefixing any other name with `yy__`. 
;This avoids collisions with C standard library functions or keywords.
---
## Standard Library Components
---
!!!<p><span class="red-status">not started</span><span class="blue-status">planned for v0.2</span></p>
---
Aims to be minimal yet useful library.
---
### Core Library
!!!<p><span class="yellow-status">in progress</span></p>
---
```text
──────────│ libs │──────────
  ▶ def version() -> str
──────────│ libs.c │──────────
  🌐 class CBool
  🌐 class CDouble
  🌐 class CInt
  🌐 class CLong
  🌐 class CShort
  🌐 class CStr
  🌐 class CUInt
  🌐 class CULong
  🌐 class CUShort
  🌐 class Size
  🌐 class VoidPtr
  ▶ def acos(x: CDouble) -> CDouble
  ▶ def asin(x: CDouble) -> CDouble
  ▶ def atan(x: CDouble) -> CDouble
  ▶ def atan2(x: CDouble, y: CDouble) -> CDouble
  ▶ def calloc(n: Size, size: Size) -> VoidPtr
  ▶ def ceil(x: CDouble) -> CDouble
  ▶ def cos(x: CDouble) -> CDouble
  ▶ def cosh(x: CDouble) -> CDouble
  ▶ def fabs(x: CDouble) -> CDouble
  ▶ def floor(x: CDouble) -> CDouble
  ▶ def fmod(x: CDouble, y: CDouble) -> CDouble
  ▶ def free(ptr: VoidPtr) -> None
  ▶ def has_command_processor() -> bool
  ▶ def itosize(i: int) -> Size
  ▶ def log(x: CDouble) -> CDouble
  ▶ def log10(x: CDouble) -> CDouble
  ▶ def log2(x: CDouble) -> CDouble
  ▶ def malloc(size: Size) -> VoidPtr
  ▶ def memcmp(str1: VoidPtr, str2: VoidPtr, size: Size) -> CInt
  ▶ def memcpy(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
  ▶ def memmove(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
  ▶ def memset(dest: VoidPtr, character: CInt, size: Size) -> VoidPtr
  ▶ def pow(x: CDouble, y: CDouble) -> CDouble
  ▶ def realloc(ptr: VoidPtr, size: Size) -> VoidPtr
  ▶ def sin(x: CDouble) -> CDouble
  ▶ def sinh(x: CDouble) -> CDouble
  ▶ def sqrt(x: CDouble) -> CDouble
  ▶ def system(program: CStr) -> None
  ▶ def tan(x: CDouble) -> CDouble
  ▶ def tanh(x: CDouble) -> CDouble
──────────│ libs.console │──────────
  🔒 BLUE: Const[int]
  🔒 CYAN: Const[int]
  🔒 GREEN: Const[int]
  🔒 PURPLE: Const[int]
  🔒 RED: Const[int]
  🔒 REWIND: Const[int]
  🔒 WHITE: Const[int]
  🔒 YELLOW: Const[int]
  ▶ def blue(x: str) -> None
  ▶ def clear() -> None
  ▶ def colour_print(colour: int, x: str) -> None
  ▶ def cyan(x: str) -> None
  ▶ def getch() -> int
  ▶ def green(x: str) -> None
  ▶ def purple(x: str) -> None
  ▶ def red(x: str) -> None
  ▶ def set_colour(c: int) -> None
  ▶ def white(x: str) -> None
  ▶ def yellow(x: str) -> None
──────────│ libs.io │──────────
  ▶ def readfile(fname: str) -> str
  ▶ def writefile(fname: str, data: str) -> bool
──────────│ libs.mpc │──────────
  🌐 class Ast: 
     • tag: libs.c.CStr
     • contents: libs.c.CStr
     • children: Array[Ast]
     • children_num: int
  🌐 class Mpc
  🌐 class Result: 
     • output: Ast
  ▶ def ast_print(r: Result) -> None
  ▶ def cleanup(a: int, v: Mpc) -> None
  ▶ def del_ast(r: Result) -> None
  ▶ def del_err(r: Result) -> None
  ▶ def err_print(r: Result) -> None
  ▶ def mpca_lang(a: int, b: str, v: Mpc) -> None
  ▶ def new(a: str) -> Mpc
  ▶ def new_result() -> Result
  ▶ def parse(a: str, b: str, v: Mpc, r: Result) -> bool
──────────│ libs.numbers │──────────
  ▶ def cstr2i(a: libs.c.CStr) -> int
──────────│ libs.os │──────────
  🌐 class ProcessResult: 
     • ok: bool
     • output: str
     • return_code: int
  🌐 class arguments: 
     • argc: int
     • argv: Array[str]
  ▶ def cwd() -> str
  ▶ def del_process_result(pr: ProcessResult) -> None
  ▶ def exe() -> str
  ▶ def exe_path() -> str
  ▶ def get_args() -> arguments
  ▶ def getenv(name: str) -> str
  ▶ def is_macos() -> bool
  ▶ def is_windows() -> bool
  ▶ def run(args: Array[str]) -> ProcessResult
  ▶ def which(binary: str) -> str
──────────│ libs.strings │──────────
  🌐 class Utf8IterateState: 
     • step_size: int
     • codepoint: int
  ▶ def contains(haystack: str, needle: str) -> bool
  ▶ def del_cstr(a: libs.c.CStr) -> None
  ▶ def del_iter(s: Utf8IterateState) -> None
  ▶ def del_str(a: libs.c.CStr) -> None
  ▶ def from_cstr(a: libs.c.CStr) -> str
  ▶ def from_cstrlen(a: libs.c.CStr, length: int) -> str
  ▶ def from_cstrlen_after(a: libs.c.CStr, length: int, after: int) -> str
  ▶ def get(s: str, pos: int) -> int
  ▶ def get_cstr(s: libs.c.CStr, pos: int) -> int
  ▶ def isempty(s: str) -> bool
  ▶ def isempty_cstr(s: libs.c.CStr) -> bool
  ▶ def iterate(s: Utf8IterateState) -> bool
  ▶ def new_iter(s: str) -> Utf8IterateState
  ▶ def ord(s: str) -> int
  ▶ def ord_cstr(s: libs.c.CStr) -> int
  ▶ def set_cstr(s: libs.c.CStr, pos: int, v: int) -> None
  ▶ def split(value: str, sep: str) -> Array[str]
  ▶ def startswith(a: str, b: str) -> bool
  ▶ def to_cstr(a: str) -> libs.c.CStr
  ▶ def valid_cstr(s: libs.c.CStr) -> bool
──────────│ libs.subprocess │──────────
  🌐 class Result: 
     • output: str
     • result: int
  ▶ def run(arguments: Array[str]) -> Result
──────────│ libs.fileformats.ini │──────────
  🌐 class Ini
  ▶ def del_ini(object: Ini) -> None
  ▶ def from_str(ini_data: str) -> Ini
  ▶ def get(object: Ini, section: str, property: str) -> str
──────────│ libs.fileformats.toml │──────────
  🌐 class Table
  🌐 class TomlArray
  ▶ def array_len(x: TomlArray) -> int
  ▶ def bool_at(x: TomlArray, pos: int) -> bool
  ▶ def bool_at_default(x: TomlArray, pos: int, default: bool) -> bool
  ▶ def del_table(x: Table) -> None
  ▶ def from_str(x: str) -> Table
  ▶ def get_array(x: Table, name: str) -> TomlArray
  ▶ def get_bool(x: Table, name: str) -> bool
  ▶ def get_bool_default(x: Table, name: str, default: bool) -> bool
  ▶ def get_int(x: Table, name: str) -> int
  ▶ def get_int_default(x: Table, name: str, default: int) -> int
  ▶ def get_string(x: Table, name: str) -> str
  ▶ def get_string_array(x: Table, name: str) -> Array[str]
  ▶ def get_string_default(x: Table, name: str, default: str) -> str
  ▶ def get_table(x: Table, name: str) -> Table
  ▶ def int_at(x: TomlArray, pos: int) -> int
  ▶ def int_at_default(x: TomlArray, pos: int, default: int) -> int
  ▶ def string_at(x: TomlArray, pos: int) -> str
  ▶ def string_at_default(x: TomlArray, pos: int, default: str) -> str
  ▶ def valid_array(x: TomlArray) -> bool
  ▶ def valid_table(x: Table) -> bool
──────────│ libs.os.path │──────────
  ▶ def basename(p: str) -> str
  ▶ def dirname(p: str) -> str
  ▶ def end_with_slash(a: str) -> bool
  ▶ def executable(p: str) -> bool
  ▶ def exists(p: str) -> bool
  ▶ def forward_slash() -> bool
  ▶ def join(a: str, b: str) -> str
  ▶ def readable(p: str) -> bool
  ▶ def writable(p: str) -> bool
──────────│ libs.strings.array │──────────
  ▶ def del_str_array(sa: Array[str]) -> None
  ▶ def extend(a: Array[str], b: Array[str]) -> Array[str]
  ▶ def join(values: Array[str], sep: str) -> str
  ▶ def new(count: int, s: str) -> Array[str]
  ▶ def prefix(sa: Array[str], prefix_str: str) -> Array[str]
  ▶ def suffix(sa: Array[str], suffix_str: str) -> Array[str]
──────────│ libs.strings.buffer │──────────
  🌐 class StringBuffer
  ▶ def append(buf: StringBuffer, v: str) -> None
  ▶ def del_buf(buf: StringBuffer) -> None
  ▶ def join(buf: StringBuffer, values: Array[str], sep: str) -> None
  ▶ def new() -> StringBuffer
  ▶ def new_size(s: int) -> StringBuffer
  ▶ def prepend(buf: StringBuffer, v: str) -> None
  ▶ def to_str(buf: StringBuffer) -> str
```
---
### UI Library
!!!<p><span class="red-status">not started</span></p>
---
Use nuklear+sokol to create UI applications.
---
```yaksha
import libs.ui
```
---
### CL Library
!!!<p><span class="red-status">not started</span></p>
---
Access to OpenCL features and parallel programming.
---
```yaksha
import libs.cl

@device
def my_program(n: int) -> int:
    return 1 + 1
    
def main() -> int:
    dvc: cl.device = cl.get_device(0)
    cl.run(dvc, my_program)
```
;Placeholder code, API is not designed yet.
---
## How does the Yaksha-lang library get packaged?
---
!!
<div class="banner-image"><img alt="Yaksha Programming Language Runtime" src="images/yk-rt.png" style="max-width: 100%;" /></div>
!!
;Multiple sources are packaged into a single header file.
;Library functionality is exposed by prefixing with `yk__` or `YK__`.
---
### Packer components
---
*`packer.py` - Run packer DSL scripts and create packaged single header libraries.
*`inctree.py` - Topological sort `#include` DAG to determine best order for combining headers.
;DAG - Directed Acyclic Graph.
*`cids.exe` - Use `stb_c_lexer.h` library to parse C code and extract identifiers.
*`single_header_packer.py` - ApoorvaJ's single header C code packager. [Repo](https://github.com/ApoorvaJ/libs/blob/master/scripts/single_header_packer.py)
*`python-patch` - techtonik's patch script. [Repo](https://github.com:techtonik/python-patch) 
*`fcpp`- Frexx C Preprocessor by Daniel Stenberg. (Patch for Windows compilation was needed, failed to compile with MSVC, works with MingW with patch).
---
### Third Party Libraries
---
;If you stack few giants, you can stand very tall on top of them.
*`sds` - Salvatore Sanfilippo's string library. (Needed a patch to support MSVC 2019)
*`stb` - Single header libraries by Sean Barrett.
*`sokol` - Useful single header libraries by Andre Weissflog. 
*`nuklear` - Single header immediate mode UI library by Micha Mettke.
*`libs` -  Mattias Gustavsson's single header C libraries.
*`utf8proc` - UTF-8 library - Jan Behrens, Public Software Group and Julia developers.
;!<br />
;Note - currently only sds and stb_ds is used. This selection of libraries may change.
---
### Packer DSL
---
```
import re
use_source("libs")
for lib in ["ini", "thread", "http"]:
    ids = extract_ids(lib + ".h")
    P = [x for x in ids if x.startswith(lib)]
    PU = [x for x in ids if x.startswith(lib.upper())]
    prefix(lib + ".h", PREFIX, P)
    prefix(lib + ".h", PREFIX_U, PU)
    rename(lib + ".h", [[re.escape(r'yk__http://'), 'http://'],
                        ["YK__THREAD_PRIORITY_HIGHEST", "THREAD_PRIORITY_HIGHEST"]])
    copy_file(lib + ".h", PREFIX + lib + ".h", is_temp=False)
    clang_format(PREFIX + lib + ".h", is_temp=False)
```
;It is just Python 3.x with extra functions added and evaluated.🤫
---