# Yaksha library
---
Yaksha library uses multiple 3rd party libraries, set of python scripts and few other nuts and bolts to create library sources. 
---
All exposed functionality starts with `yk__` or `YK__`. Yaksha programming language preserves anything that starts with `yk__` or `YK__` while prefixing any other name with `yy__`. 
;This avoids collisions with C standard library functions or keywords.
---
## Standard Library Components
---
!!!<p><span class="red-status">not started</span><span class="blue-status">planned for v0.2</span></p>
---
Aims to be minimal yet useful library.
---
### Core Library
!!!<p><span class="yellow-status">in progress</span></p>
---
```text
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â–¶ def version() -> str
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.c â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class CBool
  ðŸŒ class CDouble
  ðŸŒ class CInt
  ðŸŒ class CLong
  ðŸŒ class CShort
  ðŸŒ class CStr
  ðŸŒ class CUInt
  ðŸŒ class CULong
  ðŸŒ class CUShort
  ðŸŒ class Size
  ðŸŒ class VoidPtr
  â–¶ def acos(x: CDouble) -> CDouble
  â–¶ def asin(x: CDouble) -> CDouble
  â–¶ def atan(x: CDouble) -> CDouble
  â–¶ def atan2(x: CDouble, y: CDouble) -> CDouble
  â–¶ def calloc(n: Size, size: Size) -> VoidPtr
  â–¶ def ceil(x: CDouble) -> CDouble
  â–¶ def cos(x: CDouble) -> CDouble
  â–¶ def cosh(x: CDouble) -> CDouble
  â–¶ def fabs(x: CDouble) -> CDouble
  â–¶ def floor(x: CDouble) -> CDouble
  â–¶ def fmod(x: CDouble, y: CDouble) -> CDouble
  â–¶ def free(ptr: VoidPtr) -> None
  â–¶ def has_command_processor() -> bool
  â–¶ def itosize(i: int) -> Size
  â–¶ def log(x: CDouble) -> CDouble
  â–¶ def log10(x: CDouble) -> CDouble
  â–¶ def log2(x: CDouble) -> CDouble
  â–¶ def malloc(size: Size) -> VoidPtr
  â–¶ def memcmp(str1: VoidPtr, str2: VoidPtr, size: Size) -> CInt
  â–¶ def memcpy(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
  â–¶ def memmove(dest: VoidPtr, src: VoidPtr, size: Size) -> VoidPtr
  â–¶ def memset(dest: VoidPtr, character: CInt, size: Size) -> VoidPtr
  â–¶ def pow(x: CDouble, y: CDouble) -> CDouble
  â–¶ def realloc(ptr: VoidPtr, size: Size) -> VoidPtr
  â–¶ def sin(x: CDouble) -> CDouble
  â–¶ def sinh(x: CDouble) -> CDouble
  â–¶ def sqrt(x: CDouble) -> CDouble
  â–¶ def system(program: CStr) -> None
  â–¶ def tan(x: CDouble) -> CDouble
  â–¶ def tanh(x: CDouble) -> CDouble
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.console â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸ”’ BLUE: Const[int]
  ðŸ”’ CYAN: Const[int]
  ðŸ”’ GREEN: Const[int]
  ðŸ”’ PURPLE: Const[int]
  ðŸ”’ RED: Const[int]
  ðŸ”’ REWIND: Const[int]
  ðŸ”’ WHITE: Const[int]
  ðŸ”’ YELLOW: Const[int]
  â–¶ def blue(x: str) -> None
  â–¶ def clear() -> None
  â–¶ def colour_print(colour: int, x: str) -> None
  â–¶ def cyan(x: str) -> None
  â–¶ def getch() -> int
  â–¶ def green(x: str) -> None
  â–¶ def purple(x: str) -> None
  â–¶ def red(x: str) -> None
  â–¶ def set_colour(c: int) -> None
  â–¶ def white(x: str) -> None
  â–¶ def yellow(x: str) -> None
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.io â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â–¶ def readfile(fname: str) -> str
  â–¶ def writefile(fname: str, data: str) -> bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.mpc â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class Ast: 
     â€¢ tag: libs.c.CStr
     â€¢ contents: libs.c.CStr
     â€¢ children: Array[Ast]
     â€¢ children_num: int
  ðŸŒ class Mpc
  ðŸŒ class Result: 
     â€¢ output: Ast
  â–¶ def ast_print(r: Result) -> None
  â–¶ def cleanup(a: int, v: Mpc) -> None
  â–¶ def del_ast(r: Result) -> None
  â–¶ def del_err(r: Result) -> None
  â–¶ def err_print(r: Result) -> None
  â–¶ def mpca_lang(a: int, b: str, v: Mpc) -> None
  â–¶ def new(a: str) -> Mpc
  â–¶ def new_result() -> Result
  â–¶ def parse(a: str, b: str, v: Mpc, r: Result) -> bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.numbers â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â–¶ def cstr2i(a: libs.c.CStr) -> int
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.os â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class ProcessResult: 
     â€¢ ok: bool
     â€¢ output: str
     â€¢ return_code: int
  ðŸŒ class arguments: 
     â€¢ argc: int
     â€¢ argv: Array[str]
  â–¶ def cwd() -> str
  â–¶ def del_process_result(pr: ProcessResult) -> None
  â–¶ def exe() -> str
  â–¶ def exe_path() -> str
  â–¶ def get_args() -> arguments
  â–¶ def getenv(name: str) -> str
  â–¶ def is_macos() -> bool
  â–¶ def is_windows() -> bool
  â–¶ def run(args: Array[str]) -> ProcessResult
  â–¶ def which(binary: str) -> str
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.strings â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class Utf8IterateState: 
     â€¢ step_size: int
     â€¢ codepoint: int
  â–¶ def contains(haystack: str, needle: str) -> bool
  â–¶ def del_cstr(a: libs.c.CStr) -> None
  â–¶ def del_iter(s: Utf8IterateState) -> None
  â–¶ def del_str(a: libs.c.CStr) -> None
  â–¶ def from_cstr(a: libs.c.CStr) -> str
  â–¶ def from_cstrlen(a: libs.c.CStr, length: int) -> str
  â–¶ def from_cstrlen_after(a: libs.c.CStr, length: int, after: int) -> str
  â–¶ def get(s: str, pos: int) -> int
  â–¶ def get_cstr(s: libs.c.CStr, pos: int) -> int
  â–¶ def isempty(s: str) -> bool
  â–¶ def isempty_cstr(s: libs.c.CStr) -> bool
  â–¶ def iterate(s: Utf8IterateState) -> bool
  â–¶ def new_iter(s: str) -> Utf8IterateState
  â–¶ def ord(s: str) -> int
  â–¶ def ord_cstr(s: libs.c.CStr) -> int
  â–¶ def set_cstr(s: libs.c.CStr, pos: int, v: int) -> None
  â–¶ def split(value: str, sep: str) -> Array[str]
  â–¶ def startswith(a: str, b: str) -> bool
  â–¶ def to_cstr(a: str) -> libs.c.CStr
  â–¶ def valid_cstr(s: libs.c.CStr) -> bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.subprocess â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class Result: 
     â€¢ output: str
     â€¢ result: int
  â–¶ def run(arguments: Array[str]) -> Result
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.fileformats.ini â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class Ini
  â–¶ def del_ini(object: Ini) -> None
  â–¶ def from_str(ini_data: str) -> Ini
  â–¶ def get(object: Ini, section: str, property: str) -> str
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.fileformats.toml â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class Table
  ðŸŒ class TomlArray
  â–¶ def array_len(x: TomlArray) -> int
  â–¶ def bool_at(x: TomlArray, pos: int) -> bool
  â–¶ def bool_at_default(x: TomlArray, pos: int, default: bool) -> bool
  â–¶ def del_table(x: Table) -> None
  â–¶ def from_str(x: str) -> Table
  â–¶ def get_array(x: Table, name: str) -> TomlArray
  â–¶ def get_bool(x: Table, name: str) -> bool
  â–¶ def get_bool_default(x: Table, name: str, default: bool) -> bool
  â–¶ def get_int(x: Table, name: str) -> int
  â–¶ def get_int_default(x: Table, name: str, default: int) -> int
  â–¶ def get_string(x: Table, name: str) -> str
  â–¶ def get_string_array(x: Table, name: str) -> Array[str]
  â–¶ def get_string_default(x: Table, name: str, default: str) -> str
  â–¶ def get_table(x: Table, name: str) -> Table
  â–¶ def int_at(x: TomlArray, pos: int) -> int
  â–¶ def int_at_default(x: TomlArray, pos: int, default: int) -> int
  â–¶ def string_at(x: TomlArray, pos: int) -> str
  â–¶ def string_at_default(x: TomlArray, pos: int, default: str) -> str
  â–¶ def valid_array(x: TomlArray) -> bool
  â–¶ def valid_table(x: Table) -> bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.os.path â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â–¶ def basename(p: str) -> str
  â–¶ def dirname(p: str) -> str
  â–¶ def end_with_slash(a: str) -> bool
  â–¶ def executable(p: str) -> bool
  â–¶ def exists(p: str) -> bool
  â–¶ def forward_slash() -> bool
  â–¶ def join(a: str, b: str) -> str
  â–¶ def readable(p: str) -> bool
  â–¶ def writable(p: str) -> bool
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.strings.array â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  â–¶ def del_str_array(sa: Array[str]) -> None
  â–¶ def extend(a: Array[str], b: Array[str]) -> Array[str]
  â–¶ def join(values: Array[str], sep: str) -> str
  â–¶ def new(count: int, s: str) -> Array[str]
  â–¶ def prefix(sa: Array[str], prefix_str: str) -> Array[str]
  â–¶ def suffix(sa: Array[str], suffix_str: str) -> Array[str]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ libs.strings.buffer â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  ðŸŒ class StringBuffer
  â–¶ def append(buf: StringBuffer, v: str) -> None
  â–¶ def del_buf(buf: StringBuffer) -> None
  â–¶ def join(buf: StringBuffer, values: Array[str], sep: str) -> None
  â–¶ def new() -> StringBuffer
  â–¶ def new_size(s: int) -> StringBuffer
  â–¶ def prepend(buf: StringBuffer, v: str) -> None
  â–¶ def to_str(buf: StringBuffer) -> str
```
---
### UI Library
!!!<p><span class="red-status">not started</span></p>
---
Use nuklear+sokol to create UI applications.
---
```yaksha
import libs.ui
```
---
### CL Library
!!!<p><span class="red-status">not started</span></p>
---
Access to OpenCL features and parallel programming.
---
```yaksha
import libs.cl

@device
def my_program(n: int) -> int:
    return 1 + 1
    
def main() -> int:
    dvc: cl.device = cl.get_device(0)
    cl.run(dvc, my_program)
```
;Placeholder code, API is not designed yet.
---
## How does the Yaksha-lang library get packaged?
---
!!
<div class="banner-image"><img alt="Yaksha Programming Language Runtime" src="images/yk-rt.png" style="max-width: 100%;" /></div>
!!
;Multiple sources are packaged into a single header file.
;Library functionality is exposed by prefixing with `yk__` or `YK__`.
---
### Packer components
---
*`packer.py` - Run packer DSL scripts and create packaged single header libraries.
*`inctree.py` - Topological sort `#include` DAG to determine best order for combining headers.
;DAG - Directed Acyclic Graph.
*`cids.exe` - Use `stb_c_lexer.h` library to parse C code and extract identifiers.
*`single_header_packer.py` - ApoorvaJ's single header C code packager. [Repo](https://github.com/ApoorvaJ/libs/blob/master/scripts/single_header_packer.py)
*`python-patch` - techtonik's patch script. [Repo](https://github.com:techtonik/python-patch) 
*`fcpp`- Frexx C Preprocessor by Daniel Stenberg. (Patch for Windows compilation was needed, failed to compile with MSVC, works with MingW with patch).
---
### Third Party Libraries
---
;If you stack few giants, you can stand very tall on top of them.
*`sds` - Salvatore Sanfilippo's string library. (Needed a patch to support MSVC 2019)
*`stb` - Single header libraries by Sean Barrett.
*`sokol` - Useful single header libraries by Andre Weissflog. 
*`nuklear` - Single header immediate mode UI library by Micha Mettke.
*`libs` -  Mattias Gustavsson's single header C libraries.
*`utf8proc` - UTF-8 library - Jan Behrens, Public Software Group and Julia developers.
;!<br />
;Note - currently only sds and stb_ds is used. This selection of libraries may change.
---
### Packer DSL
---
```
import re
use_source("libs")
for lib in ["ini", "thread", "http"]:
    ids = extract_ids(lib + ".h")
    P = [x for x in ids if x.startswith(lib)]
    PU = [x for x in ids if x.startswith(lib.upper())]
    prefix(lib + ".h", PREFIX, P)
    prefix(lib + ".h", PREFIX_U, PU)
    rename(lib + ".h", [[re.escape(r'yk__http://'), 'http://'],
                        ["YK__THREAD_PRIORITY_HIGHEST", "THREAD_PRIORITY_HIGHEST"]])
    copy_file(lib + ".h", PREFIX + lib + ".h", is_temp=False)
    clang_format(PREFIX + lib + ".h", is_temp=False)
```
;It is just Python 3.x with extra functions added and evaluated.ðŸ¤«
---